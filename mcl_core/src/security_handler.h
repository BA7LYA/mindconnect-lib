/*!
 * @file     security_handler.h
 * @brief    Security handler module header file.
 *
 * This module presents security related operations.
 *
 * @copyright Copyright (C) 2019 Siemens Aktiengesellschaft.\n
 *            All rights reserved.
 */

#ifndef SECURITY_HANDLER_H_
#define SECURITY_HANDLER_H_

#include "mcl_core/mcl_core_common.h"

/**
 * Handle for RSA key pair.
 */
typedef struct rsa_t
{
    char *public_key;              //!< Public key.
    mcl_size_t public_key_length;  //!< Public key length.
    char *private_key;             //!< Private key.
    mcl_size_t private_key_length; //!< Private key length.
} rsa_t;

/**
 * Handle for security handler.
 */
typedef struct security_handler_t
{
    rsa_t rsa;                           //!< RSA handle.
    char *registration_access_token; //!< Registration access token.
    char *registration_uri;          //!< Registration URI.
    char *client_secret;             //!< Client secret.
    char *access_token;              //!< Access token.
    char *last_token_time;           //!< The time at which the last access token is generated by MindSphere.
    char *client_id;                 //!< Client id.
} security_handler_t;

/**
 * This function creates and initializes an object of type #security_handler_t.
 *
 * @param [out] security_handler Handle to be created and initialized.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_initialize(security_handler_t **security_handler);

/**
 * This function is used to generate the jti nonce.
 *
 * This generated jti nonce will be used inside of the authentication JWT.
 *
 * @param [out] jti Generated jti string : 128 bit random number, base64 encoded.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of failure.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_generate_jti(char **jti);

/**
 * This function is used to generate the sha256 hash of the given data.
 *
 * @param [in] data Data to be hashed.
 * @param [in] data_size Size of @p data.
 * @param [out] hash Generated hash result.
 * @param [out] hash_size Length of the generated @p hash.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_hash_sha256(const mcl_uint8_t *data, mcl_size_t data_size, mcl_uint8_t **hash, mcl_size_t *hash_size);

/**
 * This function calculates HMAC SHA256 for given data with the authorization key of provided @p security_handler.
 *
 * @param [in] security_handler Security handler to use its authorization key.
 * @param [in] data Data to calculate HMAC SHA256 for.
 * @param [in] data_size Size of @p data.
 * @param [out] hash A newly allocated memory which contains the result of HMAC SHA256.
 * @param [out] hash_size Size of @p hash, which should be 32 bytes after SHA256 calculation.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_INVALID_PARAMETER if key_size of @p security_handler is zero.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_SHA256_CALCULATION_FAIL if SHA256 calculation fails.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_hmac_sha256(security_handler_t *security_handler, const mcl_uint8_t *data, mcl_size_t data_size, mcl_uint8_t **hash,
        mcl_size_t *hash_size);

/**
 * This function is used to encode the given data in base64 URL encoding format.
 *
 * @param [in] data Data to be encoded.
 * @param [in] data_size Data size.
 * @param [out] encoded_data Encoded result.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_base64_url_encode(const mcl_uint8_t *data, mcl_size_t data_size, char **encoded_data);

/**
 * This function is used to encode the given data in base64 encoding format.
 *
 * @param [in] data Data to be encoded.
 * @param [in] data_size Data size.
 * @param [out] encoded_data Encoded result.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_base64_encode(const mcl_uint8_t *data, mcl_size_t data_size, char **encoded_data);

/**
 * Given a base64 zero-terminated string at @p encoded_data, decode it and return a
 * pointer in @p decoded_data to a newly allocated memory area holding decoded
 * data. Size of decoded data is returned in variable pointed by @p decoded_data_size.
 *
 * When decoded data length is 0, returns #MCL_NULL in @p decoded_data.
 *
 * @param encoded_data [in] Zero-terminated string which is base64 encoded and has to be decoded.
 * @param decoded_data [out] Newly allocated memory holding decoded data.
 * @param decoded_data_size [out] Size of decoded data.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_BAD_CONTENT_ENCODING if provided @p encoded_data has invalid length (0 or not multiples of 4) or is invalidly encoded.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_base64_decode(const char *encoded_data, mcl_uint8_t **decoded_data, mcl_size_t *decoded_data_size);

/**
 * This function is used to generate the RSA public/private key pairs.
 *
 * Generated key pairs will be stored in the received handler.
 *
 * @param [in] security_handler Handler to be used.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of an internal error in MCL.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_generate_rsa_key(security_handler_t *security_handler);

/**
 * This function is used to sign data with RSA key.
 *
 * Received key will be used to sign. Caller can use the generated RSA private key or the servers public key.
 *
 * @param [in] rsa_key The key to be used in signing.
 * @param [in] data The data to be signed.
 * @param [in] data_size Size of the data.
 * @param [out] signature Generated signature.
 * @param [out] signature_size Size of signature.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of an internal error in MCL.</li>
 * </ul>
 */
MCL_LOCAL mcl_error_t security_handler_rsa_sign(char *rsa_key, char *data, mcl_size_t data_size, mcl_uint8_t **signature, mcl_size_t *signature_size);

/**
 * This function is used to destroy the security handler.
 *
 * @param [in] security_handler Handler to be destroyed.
 */
MCL_LOCAL void security_handler_destroy(security_handler_t **security_handler);

#endif //SECURITY_HANDLER_H_
